from __future__ import annotations

from typing import TYPE_CHECKING, Literal

if TYPE_CHECKING:
    from sbibm_unle_extra.unle import TrainEvalTresults

import os
import re
from pathlib import Path
from typing import Tuple

import cloudpickle

from .parameters_to_test import (
    parameters_sets_sunle,
    parameters_sets_sunle_larger_budget,
    parameters_sets_sunle_vi,
    parameters_sets_sunle_vi_larger_budget,
    parameters_sets_unle,
    parameters_sets_unle_larger_budget,
)


def load_test_data(
    param_set: dict, method: Literal["unle", "sunle", "sunle_vi"]
) -> Tuple:
    """Load the (S)UNLE posterior samples generated using the parameters in `param_set`.

    The return value contains the posterior samples for each round.
    The function throws an error if the data cannot be found.
    """
    expected_filename = get_data_filename(param_set)
    if os.environ.get("CI") == "true":
        test_data_dir = Path(__file__).parent.absolute() / "data" / "ci-runner" / method
    else:
        test_data_dir = Path(__file__).parent.absolute() / "data" / "local" / method

    test_data_path = test_data_dir / expected_filename

    if not (test_data_path).exists():
        raise FileNotFoundError(
            f"No data file exists for {expected_filename}."
            f"If you are running the tests locally, make sure to generate the test data"
            f"by running"
            f"`python -m tests.tests_backward_reproducibility.generate_test_data`."
        )

    with open(test_data_path, "rb") as file:
        test_data = cloudpickle.load(file)

    return test_data


# ----------------------------------------------------------------------------------------------------------------------
# Argument managers
# ----------------------------------------------------------------------------------------------------------------------

def _strip_non_portable_posix_filename_pattern(s):
    """
    Converts a string to a new one that can be used as a filename on POSIX systems.

    Any leading hyphens are removed from the string to avoid problems when filenames
    are passed as command line arguments.

    .. seealso::
        https://pubs.opengroup.org/onlinepubs/9699919799.2018edition/
    """
    while s.startswith('-'):
        s = s[1:]

    posix_set = r'[^A-Za-z0-9._-]'
    s = re.sub(posix_set, '_', s)
    return s


def get_data_filename(param_dict: dict) -> str:
    """Get the filename at which to save canonical UNLE or SUNLE output data."""
    filename = []
    sorted_param_dict = dict(sorted(param_dict.items()))

    for key, value in sorted_param_dict.items():
        abbreviation = get_abbreviation(key)
        filename.append(f"{abbreviation}-{value}")

    filename = "_".join(filename) + ".pkl"

    return _strip_non_portable_posix_filename_pattern(filename)


def get_abbreviation(s: str) -> str:
    """Generate an abbreviation from a string `s`

    The abbreviation is generated by concatenating the first character of `s` and each
    character immediately following an underscore.

    Examples:
    ---------
    >>> get_abbreviation("max_iter")
    'mi'
    """
    abbreviation = [word[0] for word in s.split("_")]
    return "".join(abbreviation)


def get_param_sets(
    method: Literal["unle", "sunle", "sunle_vi"], large_budget: bool
) -> Tuple[dict, ...]:
    """Get the parameter sets to test for a given method and budget size."""
    if large_budget:
        if method == "unle":
            param_sets = parameters_sets_unle_larger_budget
        elif method == "sunle":
            param_sets = parameters_sets_sunle_larger_budget
        elif method == "sunle_vi":
            param_sets = parameters_sets_sunle_vi_larger_budget
        else:
            raise ValueError(f"Invalid method: {method}")
    else:
        if method == "unle":
            param_sets = parameters_sets_unle
        elif method == "sunle":
            param_sets = parameters_sets_sunle
        elif method == "sunle_vi":
            param_sets = parameters_sets_sunle_vi
        else:
            raise ValueError(f"Invalid method: {method}")
    return param_sets
